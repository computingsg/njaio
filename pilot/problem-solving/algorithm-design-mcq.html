<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Design MCQs - National Junior AI Olympiad</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 20px; background: linear-gradient(135deg, #f9ca24 0%, #f0932b 100%); min-height: 100vh; }
        .container { max-width: 800px; margin: 0 auto; background: white; border-radius: 15px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .header { background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%); color: white; text-align: center; padding: 30px 20px; }
        .header h1 { margin: 0; font-size: 2em; }
        .content { padding: 30px; }
        .back-btn { background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 25px; cursor: pointer; text-decoration: none; display: inline-block; margin-bottom: 20px; transition: all 0.3s ease; }
        .back-btn:hover { background: #5a6268; transform: translateY(-2px); }
        .question-container { background: #f8f9fa; border-radius: 12px; padding: 25px; margin-bottom: 25px; border-left: 5px solid #f9ca24; }
        .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .question-number { font-weight: 600; color: #f9ca24; }
        .question-text { font-size: 1.1em; margin-bottom: 20px; color: #2c3e50; }
        .options { display: grid; gap: 12px; }
        .option { background: white; border: 2px solid #e9ecef; border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.3s ease; }
        .option:hover { border-color: #f9ca24; background: #fff8e1; }
        .option.selected.correct { border-color: #4caf50; background: #e8f5e8; }
        .option.selected.incorrect { border-color: #f44336; background: #ffeaea; }
        .explanation { margin-top: 15px; padding: 15px; border-radius: 8px; display: none; }
        .explanation.correct { background: #e8f5e8; border-left: 4px solid #4caf50; color: #2e7d32; }
        .explanation.incorrect { background: #ffeaea; border-left: 4px solid #f44336; color: #c62828; }
        .reset-btn { background: #ff9800; color: white; border: none; padding: 5px 10px; border-radius: 15px; cursor: pointer; font-size: 0.8em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Algorithm Design Practice</h1>
            <p>Test your knowledge of efficient problem solving</p>
        </div>
        <div class="content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <a href="algorithm-design.html" class="back-btn" style="margin-bottom: 0;"><i class="fas fa-arrow-left"></i> Back to Algorithm Design</a>
                <a href="../index.html" class="back-btn" style="background: #2c3e50; margin-bottom: 0;"><i class="fas fa-home"></i> Home</a>
            </div>
            <div id="questions-container"></div>
        </div>
    </div>
    <script>
        const questions = [
            {
                question: "Why is Big O notation (e.g., O(n)) important in AI algorithm design?",
                options: ["It tells you the exact number of seconds code will run", "It measures the physical size of the computer chip", "It describes how the runtime scales as the input data size (n) increases", "It determines the color of the output"],
                correct: 2,
                explanation: "In AI, we deal with massive datasets. An O(n²) algorithm might work for 100 items but will fail for 1 million. Knowing the complexity helps choose efficient algorithms for training and inference. Example: Linear search O(n) vs Binary search O(log n)."
            },
            {
                question: "What is the defining characteristic of a Greedy Algorithm?",
                options: ["It makes the locally optimal choice at each step, hoping to find the global optimum", "It exhaustively searches every possible combination", "It is an algorithm that uses excessive amounts of memory", "It learns from past mistakes to improve over time"],
                correct: 0,
                explanation: "Greedy algorithms make the best immediate decision without looking ahead. They are fast but not always perfect. Example: In a 'change making' problem, taking the largest coin first is a greedy strategy."
            },
            {
                question: "How does the Divide and Conquer strategy apply to processing large AI datasets?",
                options: ["It divides the development team into smaller groups", "It deletes half the data to save processing time", "It uses two competing algorithms to find the best answer", "It breaks the dataset into smaller chunks, processes them in parallel, and combines the results"],
                correct: 3,
                explanation: "Processing terabytes of data on one machine is impossible. Divide and Conquer allows us to split the work across thousands of machines (like in distributed training), process chunks independently, and aggregate the gradients."
            },
            {
                question: "When should you use Dynamic Programming?",
                options: ["When the problem changes randomly over time", "When the problem has overlapping subproblems and optimal substructure (e.g., sequence alignment)", "When you want to create interactive websites", "When you have unlimited computational power"],
                correct: 1,
                explanation: "DP is an optimization technique that stores the results of expensive function calls and reuses them (memoization). In AI, it's used in algorithms like the Viterbi algorithm for speech recognition."
            },
            {
                question: "In the K-Nearest Neighbors (K-NN) algorithm, what does 'K' represent?",
                options: ["The number of distinct classes in the dataset", "The total number of dimensions in the feature space", "The number of neighbors to look at when classifying a new data point", "The distance in kilometers between points"],
                correct: 2,
                explanation: "K is a hyperparameter. If K=3, the algorithm looks at the 3 closest data points. If 2 are 'Cats' and 1 is 'Dog', it predicts 'Cat'. Choosing the right K is crucial for balancing noise sensitivity vs smoothing."
            },
            {
                question: "What is Breadth-First Search (BFS) used for?",
                options: ["Sorting a list of numbers", "Finding the shortest path in an unweighted graph", "Multiplying large matrices efficiently", "Encrypting sensitive data"],
                correct: 1,
                explanation: "BFS explores a graph layer by layer, visiting all neighbors of a node before moving deeper. It's guaranteed to find the shortest path in unweighted graphs."
            },
            {
                question: "What is the typical time complexity of efficient sorting algorithms like Merge Sort?",
                options: ["O(n) - Linear time", "O(n²) - Quadratic time", "O(n log n) - Linearithmic time", "O(1) - Constant time"],
                correct: 2,
                explanation: "While simple sorts like Bubble Sort are O(n²), efficient algorithms like Merge Sort and Quick Sort (average case) run in O(n log n), making them much faster for large datasets."
            },
            {
                question: "What is Recursion?",
                options: ["A function calling itself to solve smaller instances of the problem", "A loop that runs infinitely without stopping", "A database connection error", "A variable that changes its type"],
                correct: 0,
                explanation: "Recursion is a technique where a problem is solved by breaking it down into smaller, self-similar subproblems. Example: Calculating Factorial(5) = 5 * Factorial(4)."
            },
            {
                question: "What is the primary purpose of a Hash Map (Dictionary)?",
                options: ["To store data in an ordered sequential list", "To sort data automatically upon insertion", "To encrypt passwords for security", "To allow fast data retrieval (O(1) average) using unique keys"],
                correct: 3,
                explanation: "Hash maps map 'keys' to 'values', allowing you to instantly look up a value (like a phone number) if you know the key (the name), without searching through the whole list."
            },
            {
                question: "What does Space Complexity measure?",
                options: ["The physical dimensions of the computer hardware", "The amount of memory (RAM) an algorithm needs to run relative to the input size", "The total storage capacity of the hard drive", "The speed of the internet connection"],
                correct: 1,
                explanation: "Just like Time Complexity measures speed, Space Complexity ensures our algorithm doesn't crash by using more memory than the computer has available."
            }
        ];
        
        function renderQuestions() {
            const container = document.getElementById('questions-container');
            container.innerHTML = '';
            questions.forEach((q, index) => {
                const qDiv = document.createElement('div');
                qDiv.className = 'question-container';
                qDiv.innerHTML = `
                    <div class="question-header">
                        <div class="question-number">Question ${index + 1}</div>
                        <button class="reset-btn" onclick="resetQuestion(${index})">Reset</button>
                    </div>
                    <div class="question-text">${q.question}</div>
                    <div class="options">
                        ${q.options.map((opt, i) => `
                            <div class="option" onclick="checkAnswer(${index}, ${i}, this)" data-index="${i}">
                                ${opt}
                            </div>
                        `).join('')}
                    </div>
                    <div class="explanation" id="explanation-${index}"></div>
                `;
                container.appendChild(qDiv);
            });
        }

        function checkAnswer(qIndex, optIndex, element) {
            if (element.classList.contains('selected')) return; 
            
            const question = questions[qIndex];
            const options = element.parentElement.children;
            
            for (let opt of options) {
                opt.classList.add('selected');
                if (opt.dataset.index == question.correct) {
                    opt.classList.add('correct'); 
                }
            }
            
            const explanationDiv = document.getElementById(`explanation-${qIndex}`);
            if (optIndex === question.correct) {
                element.classList.add('correct');
                explanationDiv.className = 'explanation correct';
                explanationDiv.innerHTML = `<strong>✓ Correct!</strong><br>${question.explanation}`;
            } else {
                element.classList.add('incorrect');
                explanationDiv.className = 'explanation incorrect';
                explanationDiv.innerHTML = `<strong>✗ Incorrect.</strong><br>${question.explanation}`;
            }
            explanationDiv.style.display = 'block';
        }

        function resetQuestion(index) {
            const container = document.getElementById('questions-container').children[index];
            const options = container.querySelectorAll('.option');
            options.forEach(opt => {
                opt.className = 'option';
            });
            const explanation = document.getElementById(`explanation-${index}`);
            explanation.style.display = 'none';
        }

        renderQuestions();
    </script>
</body>
</html>